searchState.loadedDescShard("scarf", 0, "Scarf is a library for analyzing x86 functions.\nContains the binary that is to be analyzed, loaded to …\nBinaryFile, but caches last section from which data was …\nSingle section of a <code>BinaryFile</code>.\nCalls the function at <code>Operand</code>.\nSet <code>DestOperand</code> to <code>Operand</code> if the second <code>Operand</code> evaluates …\n<code>DestOperand</code> version of [<code>ArchId</code>], public API is similarly …\nErrors from disassembly (<code>Operation</code> generation)\nReached end of code section.\nError - Should assume that no more operations can be …\nOperations used by <code>[FlagUpdate]</code>.\nPart of <code>Operation</code>, representing an update to <code>ExecutionState</code>…\nMakes the following <code>Operation</code>s until <code>Unfreeze</code> be buffered, …\nInternal error, there’s a bug in scarf :)\nJumps to <code>to</code> if <code>condition</code> is nonzero.\nSet <code>DestOperand</code> to <code>Operand</code>.\nA sub-operation of simulated instruction.\nZero-sized error type that is returned when reading from …\nReturns to caller.\nRepresents relative virtual address.\nRepresents relative virtual address.\nSet flags based on operation type. While Move(..) could …\nSpecial instructions that are not representable by other …\nCommits any buffered operations since <code>Freeze</code> was used to …\nUnknown opcode. The tuple is <code>(opcode_bytes, opcode_len)</code>.\nOld name for <code>VirtualAddress32</code>, confusable with …\n<code>VirtualAddress32</code> represents a constant 32-bit memory …\n<code>VirtualAddress64</code> represents a constant 64-bit memory …\nContains <code>FuncAnalysis</code> and related types and traits.\nReturns the section named “.text”.\nReturns true if <code>address</code> is within this section.\nReturns end address (First byte not included) of this …\nTraits for abstracting over different CPU architecture, …\n32-bit x86 architechture state. Rexported as …\n64-bit x86 architechture state. Rexported as …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates <code>DestOperand</code> by building <code>MemAccess</code> from the …\nCreates <code>DestOperand</code> referring to memory specified by <code>mem</code>.\nPanics if given BinaryFile with no sections. (Would be …\nCreates new SpecialBytes from a byte slice at most 8 bytes …\n<code>Operand</code> and its supporting types.\nCreates a <code>BinaryFile</code> from 32-bit Windows executable at …\nCreates a <code>BinaryFile</code> from 64-bit Windows executable at …\nCreates a BinaryFile from memory buffer(s) representing …\nSearches for section containing <code>addr</code>, and reads a …\nReads a little-endian <code>VirtualAddress</code> (Same size as the …\nSearches for section containing <code>addr</code>, and reads a …\nReads an little-endian u16 from <code>addr</code> if the address is …\nSearches for section containing <code>addr</code>, and reads a …\nReads an little-endian u32 from <code>addr</code> if the address is …\nSearches for section containing <code>addr</code>, and reads a …\nReads an little-endian u32 from <code>addr</code> if the address is …\nSearches for section containing <code>addr</code>, and reads a …\nReads an u8 from <code>addr</code> if the address is within this …\nReturns <code>(address - self.base()) as u32</code>.\nReturns <code>(address - self.base()) as u64</code>.\nReturns section by name, if it exists.\nReturns a section containing the address, if it exists\nReturns iterator, which yields all <code>[BinarySection]</code>s of …\nRange is relative from base\nReceives a slice of data from address with length <code>len</code>, or …\nReceives a slice of data from address with length of `…\nReceives a slice of data from address to end of the …\nReceives a slice of data from address to end of section, …\nReturns <code>(address - self.base()) as u32</code>, or <code>None</code> if <code>address</code> …\nReturns <code>(address - self.base()) as u64</code>, or <code>None</code> if <code>address</code> …\nA trait for additional branch-specific analysis state that …\nThe trait that will be implemented by user-side code to …\nProvides access to analysis state when in a <code>Analyzer</code> …\nA no-op zero-sized type implementing <code>AnalysisState</code> that …\nReached end of code section.\nErrors from disassembly (<code>Operation</code> generation)\nThe <code>ExecutionState</code>, CPU architecture that will be used by …\nThe analysis runner of scarf.\nInternal error, there’s a bug in scarf :)\nAdditional user-defined state that will be merged by …\nUnknown opcode. The tuple is <code>(opcode_bytes, opcode_len)</code>.\nAdds a branch to be analyzed using current state.\nAdds a branch to be analyzed using given <code>ExecutionState</code> …\nFor <code>operation()</code> callback, eeturns address of the current …\nRuns the analysis, calling the user-defined callbacks …\nTakes current analysis’ state as starting state for a …\nRetreives the <code>BinaryFile</code> that was used to construct …\nCalled each time the analysis has finished a branch, …\nReturns start address of the current branch.\nCalled each time the analysis starts executing …\nCasts to Control&lt;B: Analyzer&gt; with compatible states.\nClears all branches, both analyzed and currently pending.\nClears any pending (unchecked) branches.\nConvenience for cases where <code>address + CONST * REG_SIZE</code> is …\nCauses the current branch jump to an address.\nRetreives the <code>OperandCtx</code> that was used to construct …\nReturns address of the next instruction that will be …\nCreates a new <code>FuncAnalysis</code> with user-given <code>ExecutionState</code> …\nCauses the <code>FuncAnalysis</code> to end analysis immediately after …\nCauses the <code>FuncAnalysis</code> to end the currently simulated …\nReturns mutable refence to the current branch’s …\nAttempts to find functions of a binary, accepting ones …\nSorted by callee, so looking up callers can be done with …\nRuns analyzer to end without any user interaction, …\nRuns analyzer to end with any user interaction, producing …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEither <code>op.if_mem32()</code> or <code>op.if_mem64()</code>, depending on …\nCalls the function and updates own state (Both …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>ctx.mem_access(addr, offset, E::WORD_SIZE)</code>\nEither <code>ctx.mem32()</code> or <code>ctx.mem64()</code>, depending on …\nCalled when analysis merges states of two different …\nConvenience function for <code>exec_state().move_resolved()</code>,\nConvenience function for <code>exec_state().move_to()</code>, with a …\nCreates a new <code>FuncAnalysis</code> with default <code>ExecutionState</code> and …\nCalled for each <code>Operation</code> of disassembled instruction.\nConvenience function for <code>exec_state().read_memory()</code>.\nThe returned array is sorted by value.\nConvenience function for <code>exec_state().resolve()</code>\nConvenience function for …\nConvenience function for <code>exec_state().resolve_flag()</code>\nConvenience function for <code>exec_state().resolve_mem()</code>\nConvenience function for <code>exec_state().resolve_register()</code>\nConvenience function for <code>exec_state().set_flag()</code>.\nConvenience function for <code>exec_state().set_register()</code>.\nSkips the current operation.\nDon’t use this, will be deprecated at some point. See …\nReturns mutable reference to user-defined analyzer state …\nCreates a new <code>FuncAnalysis</code> with user-given <code>ExecutionState</code> …\nConvenience function for <code>exec_state().write_memory()</code>.\nThe address is considered a stable link to a node, while …\nCan only be called on a graph with all node links being …\nCan only be called on a graph with all node links being …\nCan only be called on a graph with all node links being …\nDistance from entry, first node has 1, its connected nodes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets mutable access to state - which is fine as none of the\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTries to replace a block with a jump to another one which …\nIterates through predecessors of a single node. <code>cfg</code> must …\nRetreives a structure which can be used to lookup what …\nConverts conditions to resolved form (Relative to branch …\nThe constraint is assumed to be something that can be …\nTrait for disassembling instructions\nA trait that does (most of) arch-specific state handling.\nContains memory state as addr -&gt; value hashmap. The …\nAs the memory is stored in larger blocks than bytes (In …\nA cache which allows skipping some repeated work during …\nEither <code>scarf::VirtualAddress</code> in 32-bit or …\nAdds an additonal assumption that can’t be represented …\nAdds an additonal assumption that can’t be represented …\nUpdates state as if the call instruction was executed …\nUpdates the two states for conditional jump to have state …\nCalled on conditional jumps, splitting the state to two …\nEquivalent to <code>out.write(self.clone())</code>, but may leave <code>out</code> …\nReturns the <code>OperandCtx</code> used by <code>self</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns function start and end addresses as a relative to …\nLow-level api to read memory that is not aware of how many …\nReturns Some for al/ax/eax/rax, not for ah.\nConstructs the <code>ExecutionState</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFor constraint X, return Y: Assumes that flags are 1bit, …\nCheap check for if <code>self</code> and <code>other</code> share their hashmap.\nBit of abstraction leak, but the memory structure is …\nMerges two states to a new state, as described in …\nMoves a resolved value to (resolved) destination.\nMoves an unresolved value to unresolved destination.\nCreates a new Disassembler.\nCreates an <code>Mem[addr]</code> with MemAccessSize of VirtualAddress …\nHigh-level memory read.\nReads memory from a resolved <code>MemAccess</code>.\nConverts unresolved input <code>Operand</code> to resolved <code>Operand</code>.\nResolves to (base, offset) though base itself may contain …\nAs resolve, but applies constraints, which makes the …\nResolves a value of flag.\nConverts unresolved input <code>MemAccess</code> to resolved <code>MemAccess</code>.\nResolves a value of register.\nLow-level api to write memory that is not aware of how …\nSets a flag to resolved value.\nSets flags to a value that has already been resolved.\nSeeks to a address.\nSets a register to resolved value.\nTries to do reverse lookup to find some unresolved <code>Operand</code> …\nApplies changes from operation to the state.\nStarts at first written_byte, not at offset 0. Whether …\nHelper for ExecutionState::value_limits implementations …\nReturns smallest and largest (inclusive) value a <em>resolved</em> …\nWrites value to memory.\n0x1 = byte at address + 0 0x80 = byte at address + 7\nExecutionState for 32-bit x86 architecture. See …\nMakes all of memory undefined\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nExecutionState for 64-bit x86 architecture. See …\nMakes all of memory undefined\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTries to find an register/memory address corresponding to …\nAddition. Wraps on overflow.\nBitwise AND.\nA variable representing some CPU state, such as a register …\nRepresents architecture (<code>ExecutionState</code>) -specific state.\nEnum of arithmetic operations used by scarf <code>Operand</code>s. Used …\nInteger arithmetic expression of two <code>Operand</code>s.\nFloat arithmetic expression of two <code>Operand</code>s.\nA constant integer.\nArbitrary user-defined variable.\nDivision.\n<code>1</code> if LHS is equal to RHS, otherwise 0.\nEnumeration of arithmetic result flags of CPU.\n<code>1</code> if LHS is greater than RHS, otherwise 0. Inputs are …\nContains counts of <code>Operand</code>s interned by a single …\nLeft shift. Shifting by more than 64 results in 0.\nMemAccessSize is enum for choosing between 8/16/32/64 bit …\nA variable representing memory read. Scarf currently …\nModulo operation.\nMultiplication. Wraps on overflow, though overflowing bits …\nHigh 64 bits of a 128-bit multiplication result.\n<code>Operand</code> is the type of values in scarf.\nAn arena for allocating and interning <code>Operand</code>s.\nConvenience alias for <code>OperandContext</code> reference that avoids …\nWrapper around <code>Operand</code> which implements <code>Hash</code> on the …\nDifferent values an <code>Operand</code> can hold.\nBitwise OR.\nRight shift. Shifting by more than 64 results in 0.\nIf-else / ternary operator: <code>if .0 != 0 { .1 } else { .2 }</code>. …\nA single operand which carries all of its data with it.\nSign extends the input <code>Operand</code> from first <code>MemAccessSize</code> to …\nSigned multiplication. Does this even work?\nSubtraction. Wraps on overflow.\nConverts 64-bit integer to 64-bit float (…\nConverts 64-bit integer to 32-bit float (…\nOnly meaningful with <code>OperandType::ArithmeticFloat</code>. …\nAn “completely unknown” variable, which is result of …\nNewtype to distinguish each <code>OperandType::Undefined</code> from …\nBitwise XOR.\nReturns <code>Operand</code> for <code>left + right</code>.\nReturns <code>Operand</code> for <code>left + right</code>.\nGets base address operand without add/sub offset, and the …\nJoins the base address and offset to a single operand.\nReturns <code>Operand</code> for <code>left &amp; right</code>.\nReturns <code>Operand</code> for <code>left &amp; right</code>.\nReturns <code>(other, constant)</code> if operand is an and mask with …\nReturns <code>Operand</code> for any arithmetic operation.\nReturns <code>Operand</code> for any arithmetic operation, which will …\nReturns bit size of <code>MemAccessSize</code>.\nReturns mask where each bit corresponds to a byte.\nReturns byte size of <code>MemAccessSize</code>.\nCheap access to a small constant.\nCheap access to a small constant.\nCheap access to a small constant.\nCheap access to a small constant.\nCheap access to a small constant.\nMatches against:\nReturns <code>OperandType::Constant(value)</code> operand.\nAmount of <code>OperandType::Constant</code> operands interned.\nReturns true if self or any child operand is <code>Memory</code>.\nReturns true if self or any child operand is <code>Undefined</code>.\nCopies an operand referring to some other OperandContext …\nReturns <code>OperandType::Custom(value)</code> operand.\nReturns <code>Operand</code> for <code>left / right</code>.\nIf either of <code>a</code> or <code>b</code> matches the filter-map <code>f</code>, return the …\nReturns <code>Operand</code> for <code>left == right</code>.\nReturns <code>Operand</code> for <code>left == right</code>.\nReturns whether the operand is 8, 16, 32, or 64 bits. …\nCheap access to any <code>OperandType::Flag</code> operand.\nCheap access to <code>Flag::Carry</code> operand.\nCheap access to <code>Flag::Direction</code> operand.\nCheap access to <code>Flag::Overflow</code> operand.\nCheap access to <code>Flag::Parity</code> operand.\nCheap access to <code>Flag::Sign</code> operand.\nCheap access to <code>Flag::Zero</code> operand.\nReturns <code>Operand</code> for a float arithmetic of any operation.\nAllows specifying custom <code>fmt::Display</code> for <code>ArchId</code> values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>Operand</code> for unsigned <code>left &gt; right</code>.\nReturns <code>Operand</code> for unsigned <code>left &gt; right</code>.\nReturns <code>Operand</code> for unsigned <code>left &gt; right</code>.\nReturns <code>Operand</code> for signed <code>left &gt; right</code>.\nReturns this operand wrapped in a newtype that implements …\nAchieves the following without unnecessary interning:\nAchieves the following without unnecessary interning:\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((register, constant))</code> if operand is an and …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if self.ty is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some(arith)</code> if self.ty is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some(c)</code> if <code>self.ty</code> is <code>OperandType::Constant(c)</code>\nIf the memory has constant address (Base is <code>ctx.const_0()</code>…\nReturns <code>Some(c)</code> if <code>self.ty</code> is <code>OperandType::Custom(c)</code>\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some(mem)</code> if <code>self.ty</code> is …\nReturns <code>Some(mem)</code> if <code>self.ty</code> is …\nReturns <code>Some(mem)</code> if <code>self.ty</code> is …\nReturns <code>Some(mem)</code> if <code>self.ty</code> is …\nReturns <code>Some(mem)</code> if <code>self.ty</code> is …\nReturns <code>Some(mem)</code> if <code>self.ty</code> is …\nReturns <code>Some(mem)</code> if <code>self.ty</code> is …\nReturns <code>Some(mem)</code> if <code>self.ty</code> is …\nReturns <code>Some(mem)</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some(base)</code> only if offset is 0.\nReturns <code>Some(base)</code> if <code>self.offset</code> equals <code>offset</code> parameter.\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some(r)</code> if <code>self.ty</code> is <code>OperandType::Arch(r)</code> with …\nGets the value if it represents a register. (That is, the …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((condition, val_true, val_false))</code> if <code>self.ty</code> …\nReturns <code>Some((val, from, to))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nReturns <code>Some((left, right))</code> if <code>self.ty</code> is …\nGets counts of different types of operands interned.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if self.ty is …\nReturns true only for <code>ArithOpType::Equal</code> and …\nReturns true if <code>self.ty() == OperandType::Undefined</code>.\nReturns an type implementing <code>Iterator</code>, yielding <code>self</code>, …\nReturns an <code>Iterator</code> type similar to <code>iter</code>, expect that it …\nReturns <code>Operand</code> for <code>left &lt;&lt; right</code>.\nReturns <code>Operand</code> for <code>left &lt;&lt; right</code>.\nReturns <code>Operand</code> for <code>left &lt;&lt; right</code>.\nReturns the bitwise AND mask of <code>MemAccessSize</code>.\nReturns <code>Operand</code> for <code>MemAccessSize::Mem16</code> memory read, …\nReturns <code>Operand</code> for Mem16 with constant address.\nReturns <code>Operand</code> for <code>MemAccessSize::Mem32</code> memory read, …\nReturns <code>Operand</code> for Mem32 with constant address.\nReturns <code>Operand</code> for <code>MemAccessSize::Mem64</code> memory read, …\nReturns <code>Operand</code> for Mem64 with constant address.\nReturns <code>Operand</code> for <code>MemAccessSize::Mem8</code> memory read, using …\nReturns <code>Operand</code> for Mem8 with constant address.\nCreates <code>MemAccess</code> from base, offset, and size.\nShortcut for …\nShortcut for …\nShortcut for …\nShortcut for …\nCreates <code>Operand</code> representing <code>mem.address_op() + value</code> …\nCreates <code>Operand</code> representing <code>mem.address_op() + value</code> …\nCreates <code>Operand</code> referring to memory from parts that make …\nCreates <code>Operand</code> representing <code>mem.address_op() - value</code> …\nCreates <code>Operand</code> representing <code>mem.address_op() - value</code> …\nCreates <code>Operand</code> referring to memory from <code>MemAccess</code>.\nReturns <code>Operand</code> for <code>left % right</code>.\nReturns <code>Operand</code> for <code>left * right</code>.\nReturns <code>Operand</code> for <code>left * right</code>.\nReturns <code>self.bytes().trailing_bits()</code>\nReturns <code>Operand</code> for high 64 bits of 128-bit result of …\nReturns <code>Operand</code> for <code>left != right</code>.\nReturns <code>Operand</code> for <code>left != right</code>.\nCreates a new OperandContext.\nCreates a new <code>OperandType::Undefined(id)</code> <code>Operand</code>, where …\nConverts operand to ‘32-bit normalized form’\nReturns <code>Operand</code> for <code>left | right</code>.\nReturns <code>Operand</code> for <code>left | right</code>.\nAmount of operands interned that are not included in other …\nReturns <code>OperandType::Arch(num)</code> operand.\nReturns what bits in this value are not guaranteed to be …\nReturns <code>Operand</code> for <code>left &gt;&gt; right</code>.\nReturns <code>Operand</code> for <code>left &gt;&gt; right</code>.\nCreates an <code>OperandType::Select</code> <code>Operand.</code> `if condition != 0 …\nReturns the sign bit of variables of this <code>MemAccessSize</code> …\nCreates an <code>OperandType::SignExtend</code> <code>Operand.</code>\nReturns <code>Operand</code> for signed <code>left * right</code>.\nHow many bits large <code>Operand</code> with this <code>ArchId</code> tag is. …\nReturns <code>Operand</code> for <code>left - right</code>.\nReturns <code>Operand</code> for <code>left - right</code>.\nReturns <code>Operand</code> for <code>left - right</code>.\nAllows specifying different variable sizes for 65536-sized …\nConverts this reference to <code>&amp;&#39;e OperandContext</code> to a struct …\nAmount of all operands interned.\nWalks through sub-operands of an <code>Operand</code>, calling the …\nReturns operand limited to low <code>size</code> bits.\nReturns reference to actual enum type carrying data of …\nAmount of <code>OperandType::Undefined</code> operands interned.\nGets the actual value. Values 0-255 represent registers …\nCreates new <code>MemAccess</code> with address offset from <code>self</code> by …\nCreates new <code>MemAccess</code> with address offset from <code>self</code> by …\nReturns <code>Some(f)</code> if <code>self.ty</code> is <code>OperandType::Flag(f)</code>\nReturns <code>Operand</code> for <code>left ^ right</code>.\nReturns <code>Operand</code> for <code>left ^ right</code>.")