<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Scarf is a library for analyzing x86 functions."><title>scarf - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="scarf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../scarf/index.html">scarf</a><span class="version">0.3.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>scarf</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/scarf/lib.rs.html#1-837">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Scarf is a library for analyzing x86 functions.</p>
<p>The main concept of scarf is that the user gives <a href="analysis/struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis"><code>FuncAnalysis</code></a> a function
which will be simulated. <code>FuncAnalysis</code> will walk through the function’s different
execution paths, while calling <a href="analysis/trait.Analyzer.html" title="trait scarf::analysis::Analyzer">user-defined callbacks</a>, letting the user code
to examine execution to extract information it needs. The callback is also able to
modify state and have some control over execution, allowing scarf to be adapted for cases
where the library is not quite able to handle unusual assmebly patterns.</p>
<p>Examples of problems that could be answered with scarf:</p>
<ul>
<li>Find all child function calls of a function, where one of the arguments is
constant integer between 0x600 and 0x700</li>
<li>If the function writes a 64-bit value to <code>(Base pointer)+0x28</code>, return the base pointer
and value which was written to. That is, detect writes to a field of a struct when the
field offset is known to be 0x28.</li>
<li>Check if the function reads memory at given constant address, and track non-stack
locations where the read value is passed to.</li>
<li>Determine all constant arguments that are passed to a certain function <code>f</code>, by analyzing all
of the functions calling <code>f</code>.</li>
<li>Find a point where the function compares some value <code>x</code> to be less than constant 0x100, and
return what expression <code>x</code> is, as well as the jump address and whether it has to be
changed to always or never to jump in order to always go to <code>x &lt; 0x100</code> branch.</li>
</ul>
<p>In general, scarf is still relatively low-level in its execution representation.
Good analysis results often require user to handle edge cases, which often requires
iterative improvements to analysis code when you come across an executable that the
analysis quite does not work on. As ultimately the only input to scarf analysis is often
just the executable binary, keeping tests using those binaries to prevent scarf-using code
from suddenly regressing is a good idea.</p>
<p>Scarf strives to be fast enough to analyze an average function in less than 1 millisecond
even on slower machines. This makes it quite feasible to brute force every function of
even in larger executable in few minutes, as well as have more targeted analysis be fast
enough that it can be ran without anyone noticing. Some of this speed means giving up
accuracy, and if an adversary codegen wanted to explicitly break scarf, it would likely
at least require user callback to actively help scarf from breaking.
The simulation accuracy issues do not seem to cause too much problem in regular
compiler-generated code though.</p>
<p>The following are main types used by scarf:</p>
<ul>
<li><a href="analysis/struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis"><code>FuncAnalysis</code></a> - The entry point for scarf analysis. Walks through and keeps track of
all branches the execution may take.</li>
<li><a href="analysis/trait.Analyzer.html" title="trait scarf::analysis::Analyzer"><code>trait Analyzer</code></a> - User-implemented trait that <code>FuncAnalysis</code> calls back to,
allowing user code to query and manipulate analysis.</li>
<li><a href="analysis/struct.Control.html" title="struct scarf::analysis::Control"><code>analysis::Control</code></a> - A type passed to <code>Analyzer</code> callbacks, providing various
ways to query and manipulate analysis state.</li>
<li><a href="struct.BinaryFile.html" title="struct scarf::BinaryFile"><code>BinaryFile</code></a> - Contains sections of the binary, including code that is to be simulated.
<ul>
<li><a href="struct.BinarySection.html" title="struct scarf::BinarySection"><code>BinarySection</code></a> - A single section, practically just <code>Vec&lt;u8&gt;</code> and a base address.</li>
</ul>
</li>
<li><a href="struct.VirtualAddress32.html" title="struct scarf::VirtualAddress32"><code>VirtualAddress32</code></a> / <a href="struct.VirtualAddress64.html" title="struct scarf::VirtualAddress64"><code>VirtualAddress64</code></a> - Integer newtype representing a constant
address, usually in <code>BinaryFile</code>
<ul>
<li><a href="exec_state/trait.VirtualAddress.html" title="trait scarf::exec_state::VirtualAddress"><code>trait exec_state::VirtualAddress</code></a> - A trait allowing
handling both address sizes generically.</li>
</ul>
</li>
<li><a href="operand/struct.Operand.html" title="struct scarf::operand::Operand"><code>Operand</code></a> - The main value / expression type of scarf.</li>
<li><a href="operand/struct.OperandContext.html" title="struct scarf::operand::OperandContext"><code>OperandContext</code></a> - Allocation arena and interner for <code>Operand</code>s. Has to outlive
<code>FuncAnalysis</code>, so user code is required to create this and pass to rest of scarf.</li>
<li><a href="exec_state/trait.ExecutionState.html" title="trait scarf::exec_state::ExecutionState"><code>trait ExecutionState</code></a> - Holds all of the simulated
CPU and memory state of one point in analysis’s execution.
Concrete types are <a href="exec_state_x86/struct.ExecutionState.html" title="struct scarf::exec_state_x86::ExecutionState"><code>ExecutionStateX86</code></a> and <a href="exec_state_x86_64/struct.ExecutionState.html" title="struct scarf::exec_state_x86_64::ExecutionState"><code>ExecutionStateX86_64</code></a>.</li>
</ul>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.Analyzer"><code>pub use crate::analysis::<a class="trait" href="analysis/trait.Analyzer.html" title="trait scarf::analysis::Analyzer">Analyzer</a>;</code></dt><dt id="reexport.FuncAnalysis"><code>pub use crate::analysis::<a class="struct" href="analysis/struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis">FuncAnalysis</a>;</code></dt><dt id="reexport.ArithOpType"><code>pub use crate::operand::<a class="enum" href="operand/enum.ArithOpType.html" title="enum scarf::operand::ArithOpType">ArithOpType</a>;</code></dt><dt id="reexport.MemAccess"><code>pub use crate::operand::<a class="struct" href="operand/struct.MemAccess.html" title="struct scarf::operand::MemAccess">MemAccess</a>;</code></dt><dt id="reexport.MemAccessSize"><code>pub use crate::operand::<a class="enum" href="operand/enum.MemAccessSize.html" title="enum scarf::operand::MemAccessSize">MemAccessSize</a>;</code></dt><dt id="reexport.Operand"><code>pub use crate::operand::<a class="struct" href="operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>;</code></dt><dt id="reexport.OperandType"><code>pub use crate::operand::<a class="enum" href="operand/enum.OperandType.html" title="enum scarf::operand::OperandType">OperandType</a>;</code></dt><dt id="reexport.OperandContext"><code>pub use crate::operand::<a class="struct" href="operand/struct.OperandContext.html" title="struct scarf::operand::OperandContext">OperandContext</a>;</code></dt><dt id="reexport.OperandCtx"><code>pub use crate::operand::<a class="type" href="operand/type.OperandCtx.html" title="type scarf::operand::OperandCtx">OperandCtx</a>;</code></dt><dt id="reexport.ArchId"><code>pub use crate::operand::<a class="struct" href="operand/struct.ArchId.html" title="struct scarf::operand::ArchId">ArchId</a>;</code></dt><dt id="reexport.ExecutionState"><code>pub use crate::exec_state::<a class="trait" href="exec_state/trait.ExecutionState.html" title="trait scarf::exec_state::ExecutionState">ExecutionState</a>;</code></dt><dt id="reexport.ExecutionStateX86"><code>pub use crate::exec_state_x86::<a class="struct" href="exec_state_x86/struct.ExecutionState.html" title="struct scarf::exec_state_x86::ExecutionState">ExecutionState</a> as ExecutionStateX86;</code></dt><dt id="reexport.ExecutionStateX86_64"><code>pub use crate::exec_state_x86_64::<a class="struct" href="exec_state_x86_64/struct.ExecutionState.html" title="struct scarf::exec_state_x86_64::ExecutionState">ExecutionState</a> as ExecutionStateX86_64;</code></dt><dt id="reexport.VirtualAddress"><code>pub use crate::<a class="struct" href="struct.VirtualAddress32.html" title="struct scarf::VirtualAddress32">VirtualAddress32</a> as VirtualAddress;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="analysis/index.html" title="mod scarf::analysis">analysis</a></dt><dd>Contains <a href="analysis/struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis"><code>FuncAnalysis</code></a> and related types and traits.</dd><dt><a class="mod" href="cfg/index.html" title="mod scarf::cfg">cfg</a></dt><dt><a class="mod" href="cfg_dot/index.html" title="mod scarf::cfg_dot">cfg_dot</a></dt><dt><a class="mod" href="exec_state/index.html" title="mod scarf::exec_state">exec_<wbr>state</a></dt><dd>Traits for abstracting over different CPU architecture, and code that can be shared
between them.</dd><dt><a class="mod" href="exec_state_x86/index.html" title="mod scarf::exec_state_x86">exec_<wbr>state_<wbr>x86</a></dt><dd>32-bit x86 architechture state. Rexported as <code>scarf::ExecutionStateX86</code>.</dd><dt><a class="mod" href="exec_state_x86_64/index.html" title="mod scarf::exec_state_x86_64">exec_<wbr>state_<wbr>x86_<wbr>64</a></dt><dd>64-bit x86 architechture state. Rexported as <code>scarf::ExecutionStateX86_64</code>.</dd><dt><a class="mod" href="operand/index.html" title="mod scarf::operand">operand</a></dt><dd><a href="operand/struct.Operand.html" title="struct scarf::operand::Operand"><code>Operand</code></a> and its supporting types.</dd><dt><a class="mod" href="operation_helpers/index.html" title="mod scarf::operation_helpers">operation_<wbr>helpers</a></dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.BinaryFile.html" title="struct scarf::BinaryFile">Binary<wbr>File</a></dt><dd>Contains the binary that is to be analyzed, loaded to memory.</dd><dt><a class="struct" href="struct.BinaryFileWithCachedSection.html" title="struct scarf::BinaryFileWithCachedSection">Binary<wbr>File<wbr>With<wbr>Cached<wbr>Section</a></dt><dd>BinaryFile, but caches last section from which data was read from,
allowing faster repeated small reads when the addresses are expected,
but not required to be in same section.</dd><dt><a class="struct" href="struct.BinarySection.html" title="struct scarf::BinarySection">Binary<wbr>Section</a></dt><dd>Single section of a <a href="struct.BinaryFile.html" title="struct scarf::BinaryFile"><code>BinaryFile</code></a>.</dd><dt><a class="struct" href="struct.DestArchId.html" title="struct scarf::DestArchId">Dest<wbr>Arch<wbr>Id</a></dt><dd><a href="enum.DestOperand.html" title="enum scarf::DestOperand"><code>DestOperand</code></a> version of [<code>ArchId</code>], public API is similarly
just new with u32, get u32, though this is not tied to <a href="operand/type.OperandCtx.html" title="type scarf::operand::OperandCtx"><code>OperandCtx</code></a></dd><dt><a class="struct" href="struct.FlagUpdate.html" title="struct scarf::FlagUpdate">Flag<wbr>Update</a></dt><dd>Part of <a href="enum.Operation.html" title="enum scarf::Operation"><code>Operation</code></a>, representing an update to
<a href="exec_state/trait.ExecutionState.html" title="trait scarf::exec_state::ExecutionState"><code>ExecutionState</code>s</a> flags.</dd><dt><a class="struct" href="struct.Instruction.html" title="struct scarf::Instruction">Instruction</a></dt><dt><a class="struct" href="struct.OutOfBounds.html" title="struct scarf::OutOfBounds">OutOf<wbr>Bounds</a></dt><dd>Zero-sized error type that is returned when reading from BinaryFile by VirtualAddress cannot
be done.</dd><dt><a class="struct" href="struct.Rva.html" title="struct scarf::Rva">Rva</a></dt><dd>Represents relative virtual address.</dd><dt><a class="struct" href="struct.Rva64.html" title="struct scarf::Rva64">Rva64</a></dt><dd>Represents relative virtual address.</dd><dt><a class="struct" href="struct.SpecialBytes.html" title="struct scarf::SpecialBytes">Special<wbr>Bytes</a></dt><dt><a class="struct" href="struct.VirtualAddress32.html" title="struct scarf::VirtualAddress32">Virtual<wbr>Address32</a></dt><dd><code>VirtualAddress32</code> represents a constant 32-bit memory address.</dd><dt><a class="struct" href="struct.VirtualAddress64.html" title="struct scarf::VirtualAddress64">Virtual<wbr>Address64</a></dt><dd><code>VirtualAddress64</code> represents a constant 64-bit memory address.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.DestOperand.html" title="enum scarf::DestOperand">Dest<wbr>Operand</a></dt><dt><a class="enum" href="enum.DisasmError.html" title="enum scarf::DisasmError">Disasm<wbr>Error</a></dt><dd>Errors from disassembly (<a href="enum.Operation.html" title="enum scarf::Operation"><code>Operation</code></a> generation)</dd><dt><a class="enum" href="enum.Error.html" title="enum scarf::Error">Error</a></dt><dt><a class="enum" href="enum.FlagArith.html" title="enum scarf::FlagArith">Flag<wbr>Arith</a></dt><dd>Operations used by <code>[FlagUpdate]</code>.</dd><dt><a class="enum" href="enum.Operation.html" title="enum scarf::Operation">Operation</a></dt><dd>A sub-operation of simulated instruction.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.parse.html" title="fn scarf::parse">parse</a></dt><dd>Creates a <code>BinaryFile</code> from 32-bit Windows executable at <code>filename</code>.</dd><dt><a class="fn" href="fn.parse_x86_64.html" title="fn scarf::parse_x86_64">parse_<wbr>x86_<wbr>64</a></dt><dd>Creates a <code>BinaryFile</code> from 64-bit Windows executable at <code>filename</code>.</dd><dt><a class="fn" href="fn.raw_bin.html" title="fn scarf::raw_bin">raw_bin</a></dt><dd>Creates a BinaryFile from memory buffer(s) representing the binary sections.</dd></dl><script type="text/json" id="notable-traits-data">{"CfgNodeIter<'a, 'e, S>":"<h3>Notable traits for <code><a class=\"struct\" href=\"cfg/struct.CfgNodeIter.html\" title=\"struct scarf::cfg::CfgNodeIter\">CfgNodeIter</a>&lt;'a, 'e, S&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, 'e, S: <a class=\"trait\" href=\"cfg/trait.CfgState.html\" title=\"trait scarf::cfg::CfgState\">CfgState</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"cfg/struct.CfgNodeIter.html\" title=\"struct scarf::cfg::CfgNodeIter\">CfgNodeIter</a>&lt;'a, 'e, S&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.90.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"cfg/struct.NodeBorrow.html\" title=\"struct scarf::cfg::NodeBorrow\">NodeBorrow</a>&lt;'a, 'e, S&gt;;</div>"}</script></section></div></main></body></html>