<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Traits for abstracting over different CPU architecture, and code that can be shared between them."><title>scarf::exec_state - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="scarf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-68b7e25d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../scarf/index.html">scarf</a><span class="version">0.3.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module exec_<wbr>state</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#statics" title="Statics">Statics</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate scarf</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">scarf</a></div><h1>Module <span>exec_state</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/scarf/exec_state.rs.html#1-4131">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Traits for abstracting over different CPU architecture, and code that can be shared
between them.</p>
<p>Main points of interest are <a href="trait.ExecutionState.html" title="trait scarf::exec_state::ExecutionState"><code>ExecutionState</code></a> for the main architecture trait,
and <a href="trait.VirtualAddress.html" title="trait scarf::exec_state::VirtualAddress"><code>VirtualAddress</code></a> for the “Integer representing memory address of word size”
trait.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Constraint.html" title="struct scarf::exec_state::Constraint">Constraint</a></dt><dd>The constraint is assumed to be something that can be substituted with 1 if met
(so constraint == constval(1)).</dd><dt><a class="struct" href="struct.Memory.html" title="struct scarf::exec_state::Memory">Memory</a></dt><dd>Contains memory state as addr -&gt; value hashmap.
The ExecutionState is expected to take care of cases where memory is written with one
address and part of it is read at offset address, in practice by splitting accesses
to be word-sized, and any misaligned accesses become bitwise and-or combinations.</dd><dt><a class="struct" href="struct.MemoryValue.html" title="struct scarf::exec_state::MemoryValue">Memory<wbr>Value</a></dt><dd>As the memory is stored in larger blocks than bytes
(In effect ExecutionState words), write to nearby byte will make
entire word merge to <code>Undefined</code>. To alleviate this inaccuracy a bit,
keep track of bytes that have never been written, and consider <code>value</code>
to not apply to these bytes. This also makes smaller-than-word writes bit
more efficient when they don’t have to be merged with <code>Mem64[addr]</code> for the
untouched bytes.</dd><dt><a class="struct" href="struct.MergeStateCache.html" title="struct scarf::exec_state::MergeStateCache">Merge<wbr>State<wbr>Cache</a></dt><dd>A cache which allows skipping some repeated work during merges.</dd></dl><h2 id="statics" class="section-header">Statics<a href="#statics" class="anchor">§</a></h2><dl class="item-table"><dt><a class="static" href="static.X86_64_ARCH_DEFINITION.html" title="static scarf::exec_state::X86_64_ARCH_DEFINITION">X86_<wbr>64_<wbr>ARCH_<wbr>DEFINITION</a></dt></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Disassembler.html" title="trait scarf::exec_state::Disassembler">Disassembler</a></dt><dd>Trait for disassembling instructions</dd><dt><a class="trait" href="trait.ExecutionState.html" title="trait scarf::exec_state::ExecutionState">Execution<wbr>State</a></dt><dd>A trait that does (most of) arch-specific state handling.</dd><dt><a class="trait" href="trait.OperandCtxExtX86.html" title="trait scarf::exec_state::OperandCtxExtX86">Operand<wbr>CtxExt<wbr>X86</a></dt><dt><a class="trait" href="trait.OperandExtX86.html" title="trait scarf::exec_state::OperandExtX86">Operand<wbr>ExtX86</a></dt><dt><a class="trait" href="trait.VirtualAddress.html" title="trait scarf::exec_state::VirtualAddress">Virtual<wbr>Address</a></dt><dd>Either <code>scarf::VirtualAddress</code> in 32-bit or <code>scarf::VirtualAddress64</code> in 64-bit</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.assume_jump_flag.html" title="fn scarf::exec_state::assume_jump_flag">assume_<wbr>jump_<wbr>flag</a></dt><dd>Updates the two states for conditional jump to have state based on whether jump is taken
or not.</dd><dt><a class="fn" href="fn.is_flag_const_constraint.html" title="fn scarf::exec_state::is_flag_const_constraint">is_<wbr>flag_<wbr>const_<wbr>constraint</a></dt><dd>For constraint X, return Y:
Assumes that flags are 1bit, which isn’t super set in stone elsewhere (yet)
flag == 0 =&gt; (flag, 0)
flag != 0 =&gt; (flag, 1)
flag == 1 =&gt; (flag, 1)</dd><dt><a class="fn" href="fn.merge_constraint.html" title="fn scarf::exec_state::merge_constraint">merge_<wbr>constraint</a></dt><dt><a class="fn" href="fn.resolve_address.html" title="fn scarf::exec_state::resolve_address">resolve_<wbr>address</a></dt><dd>Resolves to (base, offset) though base itself may contain offset as well,
just tries to avoid interning new constant additions</dd><dt><a class="fn" href="fn.value_limits.html" title="fn scarf::exec_state::value_limits">value_<wbr>limits</a></dt><dd>Helper for ExecutionState::value_limits implementations with constraints</dd></dl></section></div></main></body></html>