<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A trait that does (most of) arch-specific state handling."><title>ExecutionState in scarf::exec_state - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="scarf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../scarf/index.html">scarf</a><span class="version">0.3.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Execution<wbr>State</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#resolved-and-unresolved-operands" title="Resolved and unresolved operands">Resolved and unresolved operands</a></li><li><a href="#memory-addresses" title="Memory addresses">Memory addresses</a></li></ul><h3><a href="#required-associated-consts">Required Associated Constants</a></h3><ul class="block"><li><a href="#associatedconstant.WORD_SIZE" title="WORD_SIZE">WORD_SIZE</a></li></ul><h3><a href="#required-associated-types">Required Associated Types</a></h3><ul class="block"><li><a href="#associatedtype.Disassembler" title="Disassembler">Disassembler</a></li><li><a href="#associatedtype.VirtualAddress" title="VirtualAddress">VirtualAddress</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.add_resolved_constraint" title="add_resolved_constraint">add_resolved_constraint</a></li><li><a href="#tymethod.add_resolved_constraint_from_unresolved" title="add_resolved_constraint_from_unresolved">add_resolved_constraint_from_unresolved</a></li><li><a href="#tymethod.add_unresolved_constraint" title="add_unresolved_constraint">add_unresolved_constraint</a></li><li><a href="#tymethod.apply_call" title="apply_call">apply_call</a></li><li><a href="#tymethod.clone_to" title="clone_to">clone_to</a></li><li><a href="#tymethod.ctx" title="ctx">ctx</a></li><li><a href="#tymethod.initial_state" title="initial_state">initial_state</a></li><li><a href="#tymethod.maybe_convert_memory_immutable" title="maybe_convert_memory_immutable">maybe_convert_memory_immutable</a></li><li><a href="#tymethod.merge_states" title="merge_states">merge_states</a></li><li><a href="#tymethod.move_resolved" title="move_resolved">move_resolved</a></li><li><a href="#tymethod.move_to" title="move_to">move_to</a></li><li><a href="#tymethod.read_memory" title="read_memory">read_memory</a></li><li><a href="#tymethod.resolve" title="resolve">resolve</a></li><li><a href="#tymethod.resolve_apply_constraints" title="resolve_apply_constraints">resolve_apply_constraints</a></li><li><a href="#tymethod.resolve_flag" title="resolve_flag">resolve_flag</a></li><li><a href="#tymethod.resolve_mem" title="resolve_mem">resolve_mem</a></li><li><a href="#tymethod.resolve_register" title="resolve_register">resolve_register</a></li><li><a href="#tymethod.set_flag" title="set_flag">set_flag</a></li><li><a href="#tymethod.set_flags_resolved" title="set_flags_resolved">set_flags_resolved</a></li><li><a href="#tymethod.set_register" title="set_register">set_register</a></li><li><a href="#tymethod.update" title="update">update</a></li><li><a href="#tymethod.write_memory" title="write_memory">write_memory</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.assume_jump_flag" title="assume_jump_flag">assume_jump_flag</a></li><li><a href="#method.find_functions_from_calls" title="find_functions_from_calls">find_functions_from_calls</a></li><li><a href="#method.find_functions_with_callers" title="find_functions_with_callers">find_functions_with_callers</a></li><li><a href="#method.find_relocs" title="find_relocs">find_relocs</a></li><li><a href="#method.function_ranges_from_exception_info" title="function_ranges_from_exception_info">function_ranges_from_exception_info</a></li><li><a href="#method.operand_mem_word" title="operand_mem_word">operand_mem_word</a></li><li><a href="#method.unresolve" title="unresolve">unresolve</a></li><li><a href="#method.value_limits" title="value_limits">value_limits</a></li></ul><h3><a href="#dyn-compatibility">Dyn Compatibility</a></h3><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2><a href="index.html">In scarf::<wbr>exec_<wbr>state</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">scarf</a>::<wbr><a href="index.html">exec_state</a></div><h1>Trait <span class="trait">ExecutionState</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/scarf/exec_state.rs.html#112-331">Source</a> </span></div><pre class="rust item-decl"><code>pub trait ExecutionState&lt;'e&gt;: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + 'e {
    type <a href="#associatedtype.VirtualAddress" class="associatedtype">VirtualAddress</a>: <a class="trait" href="trait.VirtualAddress.html" title="trait scarf::exec_state::VirtualAddress">VirtualAddress</a>;
    type <a href="#associatedtype.Disassembler" class="associatedtype">Disassembler</a>: <a class="trait" href="trait.Disassembler.html" title="trait scarf::exec_state::Disassembler">Disassembler</a>&lt;'e, VirtualAddress = Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;;

    const <a href="#associatedconstant.WORD_SIZE" class="constant">WORD_SIZE</a>: <a class="enum" href="../operand/enum.MemAccessSize.html" title="enum scarf::operand::MemAccessSize">MemAccessSize</a>;
<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 30 methods</span></summary>
    // Required methods
    fn <a href="#tymethod.initial_state" class="fn">initial_state</a>(
        operand_ctx: <a class="type" href="../operand/type.OperandCtx.html" title="type scarf::operand::OperandCtx">OperandCtx</a>&lt;'e&gt;,
        binary: &amp;'e <a class="struct" href="../struct.BinaryFile.html" title="struct scarf::BinaryFile">BinaryFile</a>&lt;Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;,
    ) -&gt; Self;
<span class="item-spacer"></span>    fn <a href="#tymethod.ctx" class="fn">ctx</a>(&amp;self) -&gt; <a class="type" href="../operand/type.OperandCtx.html" title="type scarf::operand::OperandCtx">OperandCtx</a>&lt;'e&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.resolve" class="fn">resolve</a>(&amp;mut self, operand: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;) -&gt; <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.resolve_mem" class="fn">resolve_mem</a>(&amp;mut self, mem: &amp;<a class="struct" href="../operand/struct.MemAccess.html" title="struct scarf::operand::MemAccess">MemAccess</a>&lt;'e&gt;) -&gt; <a class="struct" href="../operand/struct.MemAccess.html" title="struct scarf::operand::MemAccess">MemAccess</a>&lt;'e&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.resolve_apply_constraints" class="fn">resolve_apply_constraints</a>(&amp;mut self, operand: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;) -&gt; <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.resolve_register" class="fn">resolve_register</a>(&amp;mut self, register: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>) -&gt; <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.resolve_flag" class="fn">resolve_flag</a>(&amp;mut self, flag: <a class="enum" href="../operand/enum.Flag.html" title="enum scarf::operand::Flag">Flag</a>) -&gt; <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.read_memory" class="fn">read_memory</a>(&amp;mut self, mem: &amp;<a class="struct" href="../operand/struct.MemAccess.html" title="struct scarf::operand::MemAccess">MemAccess</a>&lt;'e&gt;) -&gt; <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.write_memory" class="fn">write_memory</a>(&amp;mut self, mem: &amp;<a class="struct" href="../operand/struct.MemAccess.html" title="struct scarf::operand::MemAccess">MemAccess</a>&lt;'e&gt;, value: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;);
<span class="item-spacer"></span>    fn <a href="#tymethod.update" class="fn">update</a>(&amp;mut self, operation: &amp;<a class="enum" href="../enum.Operation.html" title="enum scarf::Operation">Operation</a>&lt;'e&gt;);
<span class="item-spacer"></span>    fn <a href="#tymethod.move_to" class="fn">move_to</a>(&amp;mut self, dest: &amp;<a class="enum" href="../enum.DestOperand.html" title="enum scarf::DestOperand">DestOperand</a>&lt;'e&gt;, value: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;);
<span class="item-spacer"></span>    fn <a href="#tymethod.move_resolved" class="fn">move_resolved</a>(&amp;mut self, dest: &amp;<a class="enum" href="../enum.DestOperand.html" title="enum scarf::DestOperand">DestOperand</a>&lt;'e&gt;, value: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;);
<span class="item-spacer"></span>    fn <a href="#tymethod.set_register" class="fn">set_register</a>(&amp;mut self, register: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>, value: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;);
<span class="item-spacer"></span>    fn <a href="#tymethod.set_flag" class="fn">set_flag</a>(&amp;mut self, flag: <a class="enum" href="../operand/enum.Flag.html" title="enum scarf::operand::Flag">Flag</a>, value: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;);
<span class="item-spacer"></span>    fn <a href="#tymethod.set_flags_resolved" class="fn">set_flags_resolved</a>(
        &amp;mut self,
        flags: &amp;<a class="struct" href="../struct.FlagUpdate.html" title="struct scarf::FlagUpdate">FlagUpdate</a>&lt;'e&gt;,
        carry: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;&gt;,
    );
<span class="item-spacer"></span>    fn <a href="#tymethod.apply_call" class="fn">apply_call</a>(&amp;mut self, ret: Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>);
<span class="item-spacer"></span>    fn <a href="#tymethod.add_resolved_constraint" class="fn">add_resolved_constraint</a>(&amp;mut self, constraint: <a class="struct" href="struct.Constraint.html" title="struct scarf::exec_state::Constraint">Constraint</a>&lt;'e&gt;);
<span class="item-spacer"></span>    fn <a href="#tymethod.add_unresolved_constraint" class="fn">add_unresolved_constraint</a>(&amp;mut self, constraint: <a class="struct" href="struct.Constraint.html" title="struct scarf::exec_state::Constraint">Constraint</a>&lt;'e&gt;);
<span class="item-spacer"></span>    fn <a href="#tymethod.add_resolved_constraint_from_unresolved" class="fn">add_resolved_constraint_from_unresolved</a>(&amp;mut self);
<span class="item-spacer"></span>    fn <a href="#tymethod.merge_states" class="fn">merge_states</a>(
        old: &amp;mut Self,
        new: &amp;mut Self,
        cache: &amp;mut <a class="struct" href="struct.MergeStateCache.html" title="struct scarf::exec_state::MergeStateCache">MergeStateCache</a>&lt;'e&gt;,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.maybe_convert_memory_immutable" class="fn">maybe_convert_memory_immutable</a>(&amp;mut self, limit: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>);
<span class="item-spacer"></span>    unsafe fn <a href="#tymethod.clone_to" class="fn">clone_to</a>(&amp;self, out: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*mut </a>Self);

    // Provided methods
    fn <a href="#method.assume_jump_flag" class="fn">assume_jump_flag</a>(
        self,
        condition: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;,
        condition_resolved: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;,
    ) -&gt; (Self, Self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.value_limits" class="fn">value_limits</a>(&amp;mut self, _value: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u64.html">u64</a>, <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u64.html">u64</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.unresolve" class="fn">unresolve</a>(&amp;self, _val: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.operand_mem_word" class="fn">operand_mem_word</a>(
        ctx: <a class="type" href="../operand/type.OperandCtx.html" title="type scarf::operand::OperandCtx">OperandCtx</a>&lt;'e&gt;,
        address: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;,
        offset: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u64.html">u64</a>,
    ) -&gt; <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_functions_with_callers" class="fn">find_functions_with_callers</a>(
        _file: &amp;<a class="struct" href="../struct.BinaryFile.html" title="struct scarf::BinaryFile">BinaryFile</a>&lt;Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;,
    ) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../analysis/struct.FuncCallPair.html" title="struct scarf::analysis::FuncCallPair">FuncCallPair</a>&lt;Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_functions_from_calls" class="fn">find_functions_from_calls</a>(
        _code: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>],
        _section_base: Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>,
        _out: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;,
    ) { ... }
<span class="item-spacer"></span>    fn <a href="#method.function_ranges_from_exception_info" class="fn">function_ranges_from_exception_info</a>(
        _file: &amp;<a class="struct" href="../struct.BinaryFile.html" title="struct scarf::BinaryFile">BinaryFile</a>&lt;Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u32.html">u32</a>, <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u32.html">u32</a>)&gt;, <a class="struct" href="../struct.OutOfBounds.html" title="struct scarf::OutOfBounds">OutOfBounds</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_relocs" class="fn">find_relocs</a>(
        _file: &amp;<a class="struct" href="../struct.BinaryFile.html" title="struct scarf::BinaryFile">BinaryFile</a>&lt;Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;, <a class="struct" href="../struct.OutOfBounds.html" title="struct scarf::OutOfBounds">OutOfBounds</a>&gt; { ... }
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A trait that does (most of) arch-specific state handling.</p>
<p>ExecutionState contains the CPU state that is simulated, so registers and memory.</p>
<p>It is also “the architecture trait” for generic code that wants to handle multiple
CPU architectures, usually as <a href="../analysis/trait.Analyzer.html#associatedtype.Exec" title="associated type scarf::analysis::Analyzer::Exec"><code>Analyzer::Exec</code></a>.</p>
<h2 id="resolved-and-unresolved-operands"><a class="doc-anchor" href="#resolved-and-unresolved-operands">§</a>Resolved and unresolved operands</h2>
<p><code>ExecutionState</code> can be considered a key-value map, where keys are registers and memory,
each containing a single value, <a href="../operand/struct.Operand.html" title="struct scarf::operand::Operand"><code>Operand</code></a>. But instead of providing explicit
<code>get_register</code> function, scarf uses <code>'unresolved' Operand -&gt; 'resolved' Operand</code>
function <a href="trait.ExecutionState.html#tymethod.resolve"><code>resolve</code></a>, which replaces all registers and memory in the
input <code>Operand</code> with values from <code>ExecutionState</code>, and returns the result.</p>
<p>Unresolved operands can be thought to refer the ‘current’ state, while resolved
operands refer to state at function entry, when the initial ExecutionState was
constructed.
Most of the the user-side analysis code will likely want to just deal with
resolved operands, as they represent same value regardless of what point in analysis
they’ve been constructed. Unresolved operands are mainly useful when needing to be
concerned with instruction-level details.</p>
<p>As an example, consider the following piece of x86-64 assembly code.</p>
<div class="example-wrap"><pre class="language-text"><code>mov r8, rcx
add r8, 3
sub rcx, r8</code></pre></div>
<p>Scarf would represent these instructions as 3 <code>Operation::Move</code>s, using unresolved operands.
If the ExecutionState was just constructed and these are the first instructions executed,
The resolved values of rcx and r8 are simply the register itself, rcx and r8.
As the instructions get handled, scarf updates the values in ExecutionState:</p>
<div class="example-wrap"><pre class="language-text"><code>mov r8, rcx
Unresolved: r8 = rcx
    =&gt; `rcx` resolves to `rcx`
    =&gt; Now resolved r8 = `rcx`

add r8, 3
Unresolved: r8 = r8 + 3
    =&gt; `r8` resolves to `rcx`; `r8 + 3` resolves to `rcx + 3`
    =&gt; Now resolved r8 = `rcx + 3`

sub rcx, r8
Unresolved: rcx = rcx - r8
    =&gt; `rcx` resolves to `rcx`; `r8` resolves to `rcx + 3`; `rcx - r8` resolves to just `-3`
    =&gt; Now resolved rcx = `-3` (To be precise, 0xffff_ffff_ffff_fffd)
    =&gt; r8 still resolves to `rcx + 3`</code></pre></div>
<p><a href="../enum.Operation.html" title="enum scarf::Operation"><code>Operation</code></a>, which represents a (part of a) CPU instruction, without external state,
always contains unresolved operands, and resolving them is usually the first thing
that is done before inspecting them further.</p>
<p>When stating that a <a href="../enum.DestOperand.html" title="enum scarf::DestOperand"><code>DestOperand</code></a> is resolved or unresolved, the only behaviour changes
affect handling of <code>DestOperand::Memory</code> variant.
<a href="trait.ExecutionState.html#tymethod.update"><code>update</code></a> and <a href="trait.ExecutionState.html#tymethod.move_to"><code>move_to</code></a> consider it unresolved, and will
resolve it to get the memory address that gets written to.
<a href="trait.ExecutionState.html#tymethod.move_resolved"><code>move_resolved</code></a> will consider the memory address be already resolved.
Other variants of <code>DestOperand</code> do not change meaning between resolved or unresolved.</p>
<h2 id="memory-addresses"><a class="doc-anchor" href="#memory-addresses">§</a>Memory addresses</h2>
<p>Scarf splits memory addresses to a ‘base’ <a href="../operand/struct.Operand.html" title="struct scarf::operand::Operand"><code>Operand</code></a> and ‘offset’ <code>u64</code>. ExecutionState
will make sure that any write and reads with equivalent base and overlapping offsets will
access the same values, simulating little-endian memory. Each unique base operand is
considered a completely separate memory space from each other, which generally is
conservatively correct, and currently there is no way (outside of duplicating memory writes)
to make two separate memory address bases to alias.</p>
<p>Internally the overlapping memory is implemented as a single <code>Operand</code> at each
4- or 8-aligned offset, with bitwise ANDs, ORs, and shifts to make memory reading/writing
work without any additional handling required from outside ExecutionState. However, when
two states are <a href="../analysis/struct.FuncAnalysis.html#state-merging-and-loops">merged</a>,
the entire 4- or 8-byte range will be merged
to <code>Undefined</code>, even if only single byte of the range differed. This limitation does
not cause issues too often, but if a function stores multiple single-byte values
next to each other in memory, reading one of those bytes may give <code>Undefined</code> instead of
a more useful <code>Operand</code>.</p>
<p>See also <a href="../operand/struct.MemAccess.html" title="struct scarf::operand::MemAccess"><code>MemAccess</code></a> documentation for an overview of memory address invariants in scarf.</p>
</div></details><h2 id="required-associated-consts" class="section-header">Required Associated Constants<a href="#required-associated-consts" class="anchor">§</a></h2><div class="methods"><section id="associatedconstant.WORD_SIZE" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#118">Source</a><h4 class="code-header">const <a href="#associatedconstant.WORD_SIZE" class="constant">WORD_SIZE</a>: <a class="enum" href="../operand/enum.MemAccessSize.html" title="enum scarf::operand::MemAccessSize">MemAccessSize</a></h4></section></div><h2 id="required-associated-types" class="section-header">Required Associated Types<a href="#required-associated-types" class="anchor">§</a></h2><div class="methods"><section id="associatedtype.VirtualAddress" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#113">Source</a><h4 class="code-header">type <a href="#associatedtype.VirtualAddress" class="associatedtype">VirtualAddress</a>: <a class="trait" href="trait.VirtualAddress.html" title="trait scarf::exec_state::VirtualAddress">VirtualAddress</a></h4></section><section id="associatedtype.Disassembler" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#117">Source</a><h4 class="code-header">type <a href="#associatedtype.Disassembler" class="associatedtype">Disassembler</a>: <a class="trait" href="trait.Disassembler.html" title="trait scarf::exec_state::Disassembler">Disassembler</a>&lt;'e, VirtualAddress = Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;</h4></section></div><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.initial_state" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#121-124">Source</a><h4 class="code-header">fn <a href="#tymethod.initial_state" class="fn">initial_state</a>(
    operand_ctx: <a class="type" href="../operand/type.OperandCtx.html" title="type scarf::operand::OperandCtx">OperandCtx</a>&lt;'e&gt;,
    binary: &amp;'e <a class="struct" href="../struct.BinaryFile.html" title="struct scarf::BinaryFile">BinaryFile</a>&lt;Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;,
) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs the <code>ExecutionState</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.ctx" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#127">Source</a><h4 class="code-header">fn <a href="#tymethod.ctx" class="fn">ctx</a>(&amp;self) -&gt; <a class="type" href="../operand/type.OperandCtx.html" title="type scarf::operand::OperandCtx">OperandCtx</a>&lt;'e&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>OperandCtx</code> used by <code>self</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.resolve" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#133">Source</a><h4 class="code-header">fn <a href="#tymethod.resolve" class="fn">resolve</a>(&amp;mut self, operand: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;) -&gt; <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;</h4></section></summary><div class="docblock"><p>Converts unresolved input <code>Operand</code> to resolved <code>Operand</code>.</p>
<p>That is, all register and memory <code>Operand</code>s in the input are replaced
with what value the state has for this register or memory address.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.resolve_mem" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#144">Source</a><h4 class="code-header">fn <a href="#tymethod.resolve_mem" class="fn">resolve_mem</a>(&amp;mut self, mem: &amp;<a class="struct" href="../operand/struct.MemAccess.html" title="struct scarf::operand::MemAccess">MemAccess</a>&lt;'e&gt;) -&gt; <a class="struct" href="../operand/struct.MemAccess.html" title="struct scarf::operand::MemAccess">MemAccess</a>&lt;'e&gt;</h4></section></summary><div class="docblock"><p>Converts unresolved input <code>MemAccess</code> to resolved <code>MemAccess</code>.</p>
<p>Note that this is mostly equivalent function to <code>resolve</code>, just operating
in <code>MemAccess</code> which saves some work and <code>Operand</code> allocations that resolving
<a href="../operand/struct.MemAccess.html#method.address_op" title="method scarf::operand::MemAccess::address_op"><code>mem.address_op()</code></a> would do.</p>
<p>On the other hand, <a href="trait.ExecutionState.html#tymethod.read_memory"><code>read_memory</code></a> operates with a resolved address,
allowing reading memory which may not be practical to reach from <code>resolve()</code> or
<code>resolve_mem()</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.resolve_apply_constraints" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#152">Source</a><h4 class="code-header">fn <a href="#tymethod.resolve_apply_constraints" class="fn">resolve_apply_constraints</a>(&amp;mut self, operand: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;) -&gt; <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;</h4></section></summary><div class="docblock"><p>As resolve, but applies constraints, which makes the operation slower
but can produce more accurate results, especially for jump conditions.</p>
<p>Constraints are usually added to state when analysis reaches a jump, for example
a branch from <code>eax &gt; 5</code> jump, will have a constraint that simplifies later <code>eax &gt; 5</code>
resolves to <code>1</code>, if resolve_apply_constraints is used.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.resolve_register" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#157">Source</a><h4 class="code-header">fn <a href="#tymethod.resolve_register" class="fn">resolve_register</a>(&amp;mut self, register: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>) -&gt; <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;</h4></section></summary><div class="docblock"><p>Resolves a value of register.</p>
<p>Quicker equivalent to <code>self.resolve(ctx.register(register))</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.resolve_flag" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#162">Source</a><h4 class="code-header">fn <a href="#tymethod.resolve_flag" class="fn">resolve_flag</a>(&amp;mut self, flag: <a class="enum" href="../operand/enum.Flag.html" title="enum scarf::operand::Flag">Flag</a>) -&gt; <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;</h4></section></summary><div class="docblock"><p>Resolves a value of flag.</p>
<p>Quicker equivalent to <code>self.resolve(ctx.flag(flag))</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.read_memory" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#175">Source</a><h4 class="code-header">fn <a href="#tymethod.read_memory" class="fn">read_memory</a>(&amp;mut self, mem: &amp;<a class="struct" href="../operand/struct.MemAccess.html" title="struct scarf::operand::MemAccess">MemAccess</a>&lt;'e&gt;) -&gt; <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;</h4></section></summary><div class="docblock"><p>Reads memory from a resolved <code>MemAccess</code>.</p>
<p>Note that this differs from <code>resolve</code> and <code>resolve_mem</code>, which will always resolve
the memory address, often ending up with a different result.</p>
<p>For example, consider a function where we are interested in what the function
writes to memory pointed by it input argument, passed in register rcx. Calling
<code>resolve(Mem64[rcx])</code> or <code>resolve_mem({rcx, 0, Mem64})</code> on function return will
first resolve rcx, which may no longer hold the input argument, and then read
memory from there. Whereas <code>read_memory({rcx, 0, Mem64})</code> will read the
memory pointed by input argument, no matter what the rcx register currently holds.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.write_memory" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#180">Source</a><h4 class="code-header">fn <a href="#tymethod.write_memory" class="fn">write_memory</a>(&amp;mut self, mem: &amp;<a class="struct" href="../operand/struct.MemAccess.html" title="struct scarf::operand::MemAccess">MemAccess</a>&lt;'e&gt;, value: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;)</h4></section></summary><div class="docblock"><p>Writes value to memory.</p>
<p>Shortcut for <code>self.move_resolved(&amp;DestOperand::Memory(mem), value)</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.update" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#187">Source</a><h4 class="code-header">fn <a href="#tymethod.update" class="fn">update</a>(&amp;mut self, operation: &amp;<a class="enum" href="../enum.Operation.html" title="enum scarf::Operation">Operation</a>&lt;'e&gt;)</h4></section></summary><div class="docblock"><p>Applies changes from operation to the state.</p>
<p>This is what the analysis code will do for each non-control-flow-related <code>Operation</code>
generated, if the user does not prevent this by calling
<a href="../analysis/struct.Control.html#method.skip_operation" title="method scarf::analysis::Control::skip_operation"><code>Control::skip_operation</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.move_to" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#193">Source</a><h4 class="code-header">fn <a href="#tymethod.move_to" class="fn">move_to</a>(&amp;mut self, dest: &amp;<a class="enum" href="../enum.DestOperand.html" title="enum scarf::DestOperand">DestOperand</a>&lt;'e&gt;, value: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;)</h4></section></summary><div class="docblock"><p>Moves an unresolved value to unresolved destination.</p>
<p>Convenience method for the equivalent but more verbose
<code>update(Operation::Move(dest, value))</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.move_resolved" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#201">Source</a><h4 class="code-header">fn <a href="#tymethod.move_resolved" class="fn">move_resolved</a>(&amp;mut self, dest: &amp;<a class="enum" href="../enum.DestOperand.html" title="enum scarf::DestOperand">DestOperand</a>&lt;'e&gt;, value: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;)</h4></section></summary><div class="docblock"><p>Moves a resolved value to (resolved) destination.</p>
<p>This is the main way to update state when the value you have is
already resolved. Note that if destination is a memory address, it will be
considered to be resolved. To move a resolved value to unresolved memory address,
resolve the <code>MemAccess</code> and call <code>move_resolved</code> with that.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.set_register" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#206">Source</a><h4 class="code-header">fn <a href="#tymethod.set_register" class="fn">set_register</a>(&amp;mut self, register: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>, value: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;)</h4></section></summary><div class="docblock"><p>Sets a register to resolved value.</p>
<p>Shortcut for <code>self.move_resolved(&amp;DestOperand::Register(register), value)</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.set_flag" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#211">Source</a><h4 class="code-header">fn <a href="#tymethod.set_flag" class="fn">set_flag</a>(&amp;mut self, flag: <a class="enum" href="../operand/enum.Flag.html" title="enum scarf::operand::Flag">Flag</a>, value: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;)</h4></section></summary><div class="docblock"><p>Sets a flag to resolved value.</p>
<p>Shortcut for <code>self.move_resolved(&amp;DestOperand::Flag(register), value)</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.set_flags_resolved" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#217">Source</a><h4 class="code-header">fn <a href="#tymethod.set_flags_resolved" class="fn">set_flags_resolved</a>(
    &amp;mut self,
    flags: &amp;<a class="struct" href="../struct.FlagUpdate.html" title="struct scarf::FlagUpdate">FlagUpdate</a>&lt;'e&gt;,
    carry: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;&gt;,
)</h4></section></summary><div class="docblock"><p>Sets flags to a value that has already been resolved.</p>
<p><code>carry</code> should contain resolved value of the carry flag, if <code>FlagUpdate.ty</code> is
an operation taking carry as input (Adc or Sbb).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.apply_call" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#222">Source</a><h4 class="code-header">fn <a href="#tymethod.apply_call" class="fn">apply_call</a>(&amp;mut self, ret: Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>)</h4></section></summary><div class="docblock"><p>Updates state as if the call instruction was executed (Push return address to stack)</p>
<p>A separate function as calls are usually just stepped over.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.add_resolved_constraint" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#227">Source</a><h4 class="code-header">fn <a href="#tymethod.add_resolved_constraint" class="fn">add_resolved_constraint</a>(&amp;mut self, constraint: <a class="struct" href="struct.Constraint.html" title="struct scarf::exec_state::Constraint">Constraint</a>&lt;'e&gt;)</h4></section></summary><div class="docblock"><p>Adds an additonal assumption that can’t be represented by setting registers/etc.
Resolved constraints are useful limiting possible values a variable can have
(<a href="trait.ExecutionState.html#method.value_limits"><code>value_limits</code></a>)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.add_unresolved_constraint" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#231">Source</a><h4 class="code-header">fn <a href="#tymethod.add_unresolved_constraint" class="fn">add_unresolved_constraint</a>(&amp;mut self, constraint: <a class="struct" href="struct.Constraint.html" title="struct scarf::exec_state::Constraint">Constraint</a>&lt;'e&gt;)</h4></section></summary><div class="docblock"><p>Adds an additonal assumption that can’t be represented by setting registers/etc.
Unresolved constraints are useful for knowing that a jump chain such as <code>jg</code> followed by
<code>jle</code> ends up always jumping at <code>jle</code>.</p>
</div></details><section id="tymethod.add_resolved_constraint_from_unresolved" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#232">Source</a><h4 class="code-header">fn <a href="#tymethod.add_resolved_constraint_from_unresolved" class="fn">add_resolved_constraint_from_unresolved</a>(&amp;mut self)</h4></section><details class="toggle method-toggle" open><summary><section id="tymethod.merge_states" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#269-273">Source</a><h4 class="code-header">fn <a href="#tymethod.merge_states" class="fn">merge_states</a>(
    old: &amp;mut Self,
    new: &amp;mut Self,
    cache: &amp;mut <a class="struct" href="struct.MergeStateCache.html" title="struct scarf::exec_state::MergeStateCache">MergeStateCache</a>&lt;'e&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Merges two states to a new state, as described in
<a href="../analysis/struct.FuncAnalysis.html#state-merging-and-loops"><code>FuncAnalysis documentation</code></a>.</p>
<p>Returns <code>None</code> if the merged state would be equivalent to <code>old</code>,
otherwise the merged state is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.maybe_convert_memory_immutable" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#279">Source</a><h4 class="code-header">fn <a href="#tymethod.maybe_convert_memory_immutable" class="fn">maybe_convert_memory_immutable</a>(&amp;mut self, limit: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Bit of abstraction leak, but the memory structure is implemented as an partially
immutable hashmap to keep clones not getting out of hand. This function is used to
tell memory that it may be cloned soon, so the latest changes may be made
immutable-shared if necessary.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.clone_to" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#330">Source</a><h4 class="code-header">unsafe fn <a href="#tymethod.clone_to" class="fn">clone_to</a>(&amp;self, out: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*mut </a>Self)</h4></section></summary><div class="docblock"><p>Equivalent to <code>out.write(self.clone())</code>, but may leave <code>out</code> partially
overwritten if it panics.</p>
<p>Useful for avoiding unnecessary memcpys.</p>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.assume_jump_flag" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#245-253">Source</a><h4 class="code-header">fn <a href="#method.assume_jump_flag" class="fn">assume_jump_flag</a>(
    self,
    condition: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;,
    condition_resolved: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;,
) -&gt; (Self, Self)</h4></section></summary><div class="docblock"><p>Called on conditional jumps, splitting the state to two states which will
be used for branch that follows the jump, and for branch that doesn’t.</p>
<p>Simplest implementation can just clone the state, but this defaults to calling
<code>scarf::exec_state::assume_jump_flag</code> too, as that moves constants to flag registers
as well as updates constraints.</p>
<p>Caller makes sure that <code>condition_resolved</code> == <code>state.resolve(condition)</code>
(Or resolve_apply_constraints).</p>
<p>Returns states in <code>(jump, no_jump)</code> order.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.value_limits" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#260-262">Source</a><h4 class="code-header">fn <a href="#method.value_limits" class="fn">value_limits</a>(&amp;mut self, _value: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u64.html">u64</a>, <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u64.html">u64</a>)</h4></section></summary><div class="docblock"><p>Returns smallest and largest (inclusive) value a <em>resolved</em> <code>Operand</code> can have.</p>
<p>This usually just returns (0, u64::MAX), but the state may be able to give
better guess if a jump earlier has limited the range of possible values
for the <code>Operand</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.unresolve" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#286-288">Source</a><h4 class="code-header">fn <a href="#method.unresolve" class="fn">unresolve</a>(&amp;self, _val: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;&gt;</h4></section></summary><div class="docblock"><p>Tries to do reverse lookup to find some unresolved <code>Operand</code> for the
resolved <code>val</code>.</p>
<p>Does not provide good results; user code should implement unresolve
that meets the accuracy/performance requirements they have itself.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.operand_mem_word" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#291-297">Source</a><h4 class="code-header">fn <a href="#method.operand_mem_word" class="fn">operand_mem_word</a>(
    ctx: <a class="type" href="../operand/type.OperandCtx.html" title="type scarf::operand::OperandCtx">OperandCtx</a>&lt;'e&gt;,
    address: <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;,
    offset: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u64.html">u64</a>,
) -&gt; <a class="struct" href="../operand/struct.Operand.html" title="struct scarf::operand::Operand">Operand</a>&lt;'e&gt;</h4></section></summary><div class="docblock"><p>Creates an <code>Mem[addr]</code> with MemAccessSize of VirtualAddress size.</p>
</div></details><section id="method.find_functions_with_callers" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#300-301">Source</a><h4 class="code-header">fn <a href="#method.find_functions_with_callers" class="fn">find_functions_with_callers</a>(
    _file: &amp;<a class="struct" href="../struct.BinaryFile.html" title="struct scarf::BinaryFile">BinaryFile</a>&lt;Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;,
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../analysis/struct.FuncCallPair.html" title="struct scarf::analysis::FuncCallPair">FuncCallPair</a>&lt;Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;&gt;</h4></section><section id="method.find_functions_from_calls" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#303-308">Source</a><h4 class="code-header">fn <a href="#method.find_functions_from_calls" class="fn">find_functions_from_calls</a>(
    _code: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>],
    _section_base: Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>,
    _out: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;,
)</h4></section><details class="toggle method-toggle" open><summary><section id="method.function_ranges_from_exception_info" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#314-318">Source</a><h4 class="code-header">fn <a href="#method.function_ranges_from_exception_info" class="fn">function_ranges_from_exception_info</a>(
    _file: &amp;<a class="struct" href="../struct.BinaryFile.html" title="struct scarf::BinaryFile">BinaryFile</a>&lt;Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u32.html">u32</a>, <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u32.html">u32</a>)&gt;, <a class="struct" href="../struct.OutOfBounds.html" title="struct scarf::OutOfBounds">OutOfBounds</a>&gt;</h4></section></summary><div class="docblock"><p>Returns function start and end addresses as a relative to base.</p>
<p>The returned addresses are expected to be sorted and not have overlaps.
(Though it currently trusts that the binary follows PE spec)</p>
</div></details><section id="method.find_relocs" class="method"><a class="src rightside" href="../../src/scarf/exec_state.rs.html#320-324">Source</a><h4 class="code-header">fn <a href="#method.find_relocs" class="fn">find_relocs</a>(
    _file: &amp;<a class="struct" href="../struct.BinaryFile.html" title="struct scarf::BinaryFile">BinaryFile</a>&lt;Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;Self::<a class="associatedtype" href="trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;, <a class="struct" href="../struct.OutOfBounds.html" title="struct scarf::OutOfBounds">OutOfBounds</a>&gt;</h4></section></div><h2 id="dyn-compatibility" class="section-header">Dyn Compatibility<a href="#dyn-compatibility" class="anchor">§</a></h2><div class="dyn-compatibility-info"><p>This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.90.0/reference/items/traits.html#dyn-compatibility">dyn compatible</a>.</p><p><i>In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.</i></p></div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><details class="toggle implementors-toggle"><summary><section id="impl-ExecutionState%3C'e%3E-for-ExecutionState%3C'e%3E" class="impl"><a class="src rightside" href="../../src/scarf/exec_state_x86.rs.html#20-221">Source</a><a href="#impl-ExecutionState%3C'e%3E-for-ExecutionState%3C'e%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'e&gt; <a class="trait" href="trait.ExecutionState.html" title="trait scarf::exec_state::ExecutionState">ExecutionState</a>&lt;'e&gt; for scarf::exec_state_x86::<a class="struct" href="../exec_state_x86/struct.ExecutionState.html" title="struct scarf::exec_state_x86::ExecutionState">ExecutionState</a>&lt;'e&gt;</h3></section></summary><div class="impl-items"><section id="associatedconstant.WORD_SIZE-1" class="associatedconstant trait-impl"><a class="src rightside" href="../../src/scarf/exec_state_x86.rs.html#23">Source</a><a href="#associatedconstant.WORD_SIZE-1" class="anchor">§</a><h4 class="code-header">const <a href="#associatedconstant.WORD_SIZE" class="constant">WORD_SIZE</a>: <a class="enum" href="../operand/enum.MemAccessSize.html" title="enum scarf::operand::MemAccessSize">MemAccessSize</a> = MemAccessSize::Mem32</h4></section><section id="associatedtype.VirtualAddress-1" class="associatedtype trait-impl"><a class="src rightside" href="../../src/scarf/exec_state_x86.rs.html#21">Source</a><a href="#associatedtype.VirtualAddress-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.VirtualAddress" class="associatedtype">VirtualAddress</a> = <a class="struct" href="../struct.VirtualAddress32.html" title="struct scarf::VirtualAddress32">VirtualAddress32</a></h4></section><section id="associatedtype.Disassembler-1" class="associatedtype trait-impl"><a class="src rightside" href="../../src/scarf/exec_state_x86.rs.html#22">Source</a><a href="#associatedtype.Disassembler-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Disassembler" class="associatedtype">Disassembler</a> = Disassembler32&lt;'e&gt;</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ExecutionState%3C'e%3E-for-ExecutionState%3C'e%3E-1" class="impl"><a class="src rightside" href="../../src/scarf/exec_state_x86_64.rs.html#128-307">Source</a><a href="#impl-ExecutionState%3C'e%3E-for-ExecutionState%3C'e%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'e&gt; <a class="trait" href="trait.ExecutionState.html" title="trait scarf::exec_state::ExecutionState">ExecutionState</a>&lt;'e&gt; for scarf::exec_state_x86_64::<a class="struct" href="../exec_state_x86_64/struct.ExecutionState.html" title="struct scarf::exec_state_x86_64::ExecutionState">ExecutionState</a>&lt;'e&gt;</h3></section></summary><div class="impl-items"><section id="associatedconstant.WORD_SIZE-2" class="associatedconstant trait-impl"><a class="src rightside" href="../../src/scarf/exec_state_x86_64.rs.html#131">Source</a><a href="#associatedconstant.WORD_SIZE-2" class="anchor">§</a><h4 class="code-header">const <a href="#associatedconstant.WORD_SIZE" class="constant">WORD_SIZE</a>: <a class="enum" href="../operand/enum.MemAccessSize.html" title="enum scarf::operand::MemAccessSize">MemAccessSize</a> = MemAccessSize::Mem64</h4></section><section id="associatedtype.VirtualAddress-2" class="associatedtype trait-impl"><a class="src rightside" href="../../src/scarf/exec_state_x86_64.rs.html#129">Source</a><a href="#associatedtype.VirtualAddress-2" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.VirtualAddress" class="associatedtype">VirtualAddress</a> = <a class="struct" href="../struct.VirtualAddress64.html" title="struct scarf::VirtualAddress64">VirtualAddress64</a></h4></section><section id="associatedtype.Disassembler-2" class="associatedtype trait-impl"><a class="src rightside" href="../../src/scarf/exec_state_x86_64.rs.html#130">Source</a><a href="#associatedtype.Disassembler-2" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Disassembler" class="associatedtype">Disassembler</a> = Disassembler64&lt;'e&gt;</h4></section></div></details></div><script src="../../trait.impl/scarf/exec_state/trait.ExecutionState.js" async></script></section></div></main></body></html>