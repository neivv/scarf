<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The analysis runner of scarf."><title>FuncAnalysis in scarf::analysis - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="scarf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../scarf/index.html">scarf</a><span class="version">0.3.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Func<wbr>Analysis</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#state-merging-and-loops" title="State merging and loops">State merging and loops</a><ul><li><a href="#example" title="Example">Example</a></li><li><a href="#other-merge-details" title="Other merge details">Other merge details</a></li></ul></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.analyze" title="analyze">analyze</a></li><li><a href="#method.custom_state" title="custom_state">custom_state</a></li><li><a href="#method.finish" title="finish">finish</a></li><li><a href="#method.finish_with_changes" title="finish_with_changes">finish_with_changes</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.with_state" title="with_state">with_state</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-FuncAnalysis%3C'a,+Exec,+State%3E" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-Send-for-FuncAnalysis%3C'a,+Exec,+State%3E" title="!Send">!Send</a></li><li><a href="#impl-Sync-for-FuncAnalysis%3C'a,+Exec,+State%3E" title="!Sync">!Sync</a></li><li><a href="#impl-UnwindSafe-for-FuncAnalysis%3C'a,+Exec,+State%3E" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Freeze-for-FuncAnalysis%3C'a,+Exec,+State%3E" title="Freeze">Freeze</a></li><li><a href="#impl-Unpin-for-FuncAnalysis%3C'a,+Exec,+State%3E" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In scarf::<wbr>analysis</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">scarf</a>::<wbr><a href="index.html">analysis</a></div><h1>Struct <span class="struct">FuncAnalysis</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/scarf/analysis.rs.html#610-660">Source</a> </span></div><pre class="rust item-decl"><code>pub struct FuncAnalysis&lt;'a, Exec: <a class="trait" href="../exec_state/trait.ExecutionState.html" title="trait scarf::exec_state::ExecutionState">ExecutionState</a>&lt;'a&gt;, State: <a class="trait" href="trait.AnalysisState.html" title="trait scarf::analysis::AnalysisState">AnalysisState</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The analysis runner of scarf.</p>
<p><code>FuncAnalysis</code> executes through all paths (‘branches’) of a function, calling
user-defined callbacks in <a href="trait.Analyzer.html" title="trait scarf::analysis::Analyzer"><code>Analyzer</code></a> for every state-modifying operation, while
keeping track of what branches have been already executed.</p>
<h2 id="state-merging-and-loops"><a class="doc-anchor" href="#state-merging-and-loops">§</a>State merging and loops</h2>
<p>When two separate branches of execution converge, <code>FuncAnalysis</code> will merge the
<a href="../exec_state/trait.ExecutionState.html" title="trait scarf::exec_state::ExecutionState"><code>ExecutionState</code></a> of branches: Any <a href="../operand/struct.Operand.html" title="struct scarf::operand::Operand"><code>Operand</code></a> in registers or in memory that differs
will be replaced with <code>OperandType::Undefined</code> if it wasn’t <code>Undefined</code> already. If this
caused anything in <code>ExecutionState</code> to change, the following branch will be analyzed
again, even if analysis had already walked through its instruction once.</p>
<p>Scarf does not have any special understanding of loops, a jump backwards is just another
merge point. This effectively often makes scarf to provide user code an <code>ExecutionState</code>
that reports registers to contain constants and jumps to be always/never taken for first
iteration of a loop, and later on run the branch ‘correctly’ with <code>Undefined</code> when the
jump backwards has been seen.</p>
<h3 id="example"><a class="doc-anchor" href="#example">§</a>Example</h3>
<p>The following code is a <code>strlen</code> implementation in x86-64 assembly. Register <code>rcx</code> has
the null-terminated input string, and <code>rax</code> will contain the string length on return.</p>
<div class="example-wrap"><pre class="language-asm"><code>entry:
    mov rax, 0
loop:
    movzx rdx, byte [rcx]
    add rax, 1
    add rcx, 1
    cmp rdx, 0
    jne loop
exit:
    sub rax, 1 ; Account for null byte having been counted above
    ret</code></pre></div>
<p>Scarf considers there to 3 branches:</p>
<ol>
<li>Branch from <code>entry</code> to <code>exit</code></li>
<li>Branch from <code>loop</code> to <code>exit</code></li>
<li>Branch from <code>exit</code> that returns</li>
</ol>
<p>Note that both branch 1 and 2 include the loop instructions. In this case, the backwards
jump can only be known to be possibly taken after the first branch has already been
simulated, so there would have been no way for scarf to know that <code>movzx rdx, byte [rcx]</code>
will be a start of another branch. For consistency, even if a jump to current instruction
has been seen, scarf will walk each branch until it sees a jump or return instruction.</p>
<p>On analysis start, scarf will execute branch 1, seeing that on jump the execution splits
to two new branches. <a href="../exec_state/trait.ExecutionState.html#tymethod.resolve" title="method scarf::exec_state::ExecutionState::resolve">Resolving</a> <code>rax</code> during this will return
constant 0, later on 1, and resolving the jump condition at the end of the branch
gives <code>(Mem8[rcx] == 0) == 0</code> - “Jump if first byte of argument <code>rcx</code> is nonzero”.</p>
<p>After the first branch, both branches 2 and 3 are queued; there is no guarantee
which will be analyzed first. If branch 3 is first, scarf will report the function to
return (resolving <code>rax</code>) constant 0. Once branch 2 is analyzed, it will have similar
‘known’ results what branch 1 shows (<code>rax</code> changes from 1 to 2, jump condition is
<code>(Mem8[rcx + 1] == 0) == 0</code>), as this is the first time branch has started from there.</p>
<p>As branch 2 analysis reaches the jump, scarf queues branches 2 and 3, and notices that the
values in registers <code>rax</code>, <code>rcx</code>, and <code>rdx</code> differ from what the older branches 2 and 3 had.
Each of those registers will be assigned an <code>Undefined</code> value for the new queued branches.
If branch 3 wasn’t analyzed yet, the state with <code>Undefined</code> overwrites the earlier queued
‘will-return-zero’ state.</p>
<p>Finally, scarf walks through branches 2 and 3 with the undefined state (in either order).
At end of this second run of branch 2, <code>rax</code> will have value <code>Undefined_a + 1</code>, rcx has
<code>Undefined_b + 1</code>, and rdx has <code>Mem8[Undefined_b]</code>. These do not add anything over the
states where these registers were <code>Undefined</code>, so no more branches will be queued.</p>
<p>Since branch 3 contains <code>sub rax, 1</code> instruction, the final return value reported by
scarf is the not-very-helpful <code>Undefined - 1</code>.</p>
<h3 id="other-merge-details"><a class="doc-anchor" href="#other-merge-details">§</a>Other merge details</h3>
<p>In general, <a href="../operand/struct.Operand.html" title="struct scarf::operand::Operand"><code>Operand</code></a> merging is defined as “If old value is undefined or differs from new,
merge to unique undefined value”. However, there are few details that are worth noting:</p>
<ul>
<li>Undefined values allocated during <code>FuncAnalysis::analyze</code> call will get reused after
the call returns. This is mainly worth noting if user code returns results as <code>Operand</code>,
and compares them to values from other analysis runs.</li>
<li>If old or new value is undefined, the merged value may recycle either of those values, or
allocate a new unique undefined.</li>
<li>When values in memory are merged, a single unit of <code>Operand</code> to be merged is not a byte,
but a word (4 or 8 bytes, depending on the <code>ExecutionState</code>). This means that if code
has byte-sized globals or structure fields, they may be assigned <code>Undefined</code> because
values neighbour address differed. So far this has rarely ended up causing issues, but
it may sometimes need special handling from user code.</li>
<li>If the address operand of memory contains <code>Undefined</code> at all, the merge operation may
drop the value entirely, reverting it back to ‘original’.
<ul>
<li>That is, while a write of <code>5</code> to <code>Mem32[Undefined + 4]</code> is guaranteed to resolve to <code>5</code>
in same branch as the write, later branches may resolve just to <code>Mem32[Undefined + 4]</code>
again.</li>
</ul>
</li>
</ul>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-FuncAnalysis%3C'a,+Exec,+DefaultState%3E" class="impl"><a class="src rightside" href="../../src/scarf/analysis.rs.html#1080-1112">Source</a><a href="#impl-FuncAnalysis%3C'a,+Exec,+DefaultState%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, Exec: <a class="trait" href="../exec_state/trait.ExecutionState.html" title="trait scarf::exec_state::ExecutionState">ExecutionState</a>&lt;'a&gt;&gt; <a class="struct" href="struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis">FuncAnalysis</a>&lt;'a, Exec, <a class="struct" href="struct.DefaultState.html" title="struct scarf::analysis::DefaultState">DefaultState</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../src/scarf/analysis.rs.html#1083-1095">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(
    binary: &amp;'a <a class="struct" href="../struct.BinaryFile.html" title="struct scarf::BinaryFile">BinaryFile</a>&lt;Exec::<a class="associatedtype" href="../exec_state/trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;,
    ctx: <a class="type" href="../operand/type.OperandCtx.html" title="type scarf::operand::OperandCtx">OperandCtx</a>&lt;'a&gt;,
    start_address: Exec::<a class="associatedtype" href="../exec_state/trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>,
) -&gt; <a class="struct" href="struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis">FuncAnalysis</a>&lt;'a, Exec, <a class="struct" href="struct.DefaultState.html" title="struct scarf::analysis::DefaultState">DefaultState</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new <code>FuncAnalysis</code> with default <code>ExecutionState</code> and no custom
user-side state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_state" class="method"><a class="src rightside" href="../../src/scarf/analysis.rs.html#1099-1111">Source</a><h4 class="code-header">pub fn <a href="#method.with_state" class="fn">with_state</a>(
    binary: &amp;'a <a class="struct" href="../struct.BinaryFile.html" title="struct scarf::BinaryFile">BinaryFile</a>&lt;Exec::<a class="associatedtype" href="../exec_state/trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;,
    ctx: <a class="type" href="../operand/type.OperandCtx.html" title="type scarf::operand::OperandCtx">OperandCtx</a>&lt;'a&gt;,
    start_address: Exec::<a class="associatedtype" href="../exec_state/trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>,
    state: Exec,
) -&gt; <a class="struct" href="struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis">FuncAnalysis</a>&lt;'a, Exec, <a class="struct" href="struct.DefaultState.html" title="struct scarf::analysis::DefaultState">DefaultState</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new <code>FuncAnalysis</code> with user-given <code>ExecutionState</code> and no custom
user-side state.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FuncAnalysis%3C'a,+Exec,+State%3E" class="impl"><a class="src rightside" href="../../src/scarf/analysis.rs.html#1114-1427">Source</a><a href="#impl-FuncAnalysis%3C'a,+Exec,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, Exec: <a class="trait" href="../exec_state/trait.ExecutionState.html" title="trait scarf::exec_state::ExecutionState">ExecutionState</a>&lt;'a&gt;, State: <a class="trait" href="trait.AnalysisState.html" title="trait scarf::analysis::AnalysisState">AnalysisState</a>&gt; <a class="struct" href="struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis">FuncAnalysis</a>&lt;'a, Exec, State&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.custom_state" class="method"><a class="src rightside" href="../../src/scarf/analysis.rs.html#1117-1126">Source</a><h4 class="code-header">pub fn <a href="#method.custom_state" class="fn">custom_state</a>(
    binary: &amp;'a <a class="struct" href="../struct.BinaryFile.html" title="struct scarf::BinaryFile">BinaryFile</a>&lt;Exec::<a class="associatedtype" href="../exec_state/trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>&gt;,
    ctx: <a class="type" href="../operand/type.OperandCtx.html" title="type scarf::operand::OperandCtx">OperandCtx</a>&lt;'a&gt;,
    start_address: Exec::<a class="associatedtype" href="../exec_state/trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>,
    exec_state: Exec,
    analysis_state: State,
) -&gt; <a class="struct" href="struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis">FuncAnalysis</a>&lt;'a, Exec, State&gt;</h4></section></summary><div class="docblock"><p>Creates a new <code>FuncAnalysis</code> with user-given <code>ExecutionState</code> and custom
user-side state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.analyze" class="method"><a class="src rightside" href="../../src/scarf/analysis.rs.html#1206-1224">Source</a><h4 class="code-header">pub fn <a href="#method.analyze" class="fn">analyze</a>&lt;A: <a class="trait" href="trait.Analyzer.html" title="trait scarf::analysis::Analyzer">Analyzer</a>&lt;'a, State = State, Exec = Exec&gt;&gt;(
    &amp;mut self,
    analyzer: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut A</a>,
)</h4></section></summary><div class="docblock"><p>Runs the analysis, calling the user-defined callbacks defined on <a href="trait.Analyzer.html" title="trait scarf::analysis::Analyzer"><code>Analyzer</code></a> trait
as the code is being stepped thorugh.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.finish" class="method"><a class="src rightside" href="../../src/scarf/analysis.rs.html#1385-1387">Source</a><h4 class="code-header">pub fn <a href="#method.finish" class="fn">finish</a>(self) -&gt; <a class="type" href="type.Cfg.html" title="type scarf::analysis::Cfg">Cfg</a>&lt;'a, Exec, State&gt;</h4></section></summary><div class="docblock"><p>Runs analyzer to end without any user interaction, producing <code>Cfg</code></p>
<p>Calling this is not necessary if you do not need a <code>Cfg</code>.</p>
<p>Currently if <a href="struct.Control.html#method.end_analysis" title="method scarf::analysis::Control::end_analysis"><code>Control::end_analysis</code></a> has been used to stop the analysis,
any remaining branches (but not the one that was being analyzed on <code>end_analysis</code> call!)
will be walked through to gain a ‘better’ idea of the control flow graph. This is somewhat
inconsistent behaviour and should be changed to not analyze any pending branches once
all users relying on this have migrated.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.finish_with_changes" class="method"><a class="src rightside" href="../../src/scarf/analysis.rs.html#1393-1426">Source</a><h4 class="code-header">pub fn <a href="#method.finish_with_changes" class="fn">finish_with_changes</a>&lt;F&gt;(self, hook: F) -&gt; <a class="type" href="type.Cfg.html" title="type scarf::analysis::Cfg">Cfg</a>&lt;'a, Exec, State&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="enum" href="../enum.Operation.html" title="enum scarf::Operation">Operation</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut Exec</a>, Exec::<a class="associatedtype" href="../exec_state/trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>),</div></h4></section></summary><div class="docblock"><p>Runs analyzer to end with any user interaction, producing <code>Cfg</code>.</p>
<p>Maybe to be removed later? User code should ideally not use <code>end_analysis</code> and
expect that any pending branches get processed by finish().</p>
</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-FuncAnalysis%3C'a,+Exec,+State%3E" class="impl"><a href="#impl-Freeze-for-FuncAnalysis%3C'a,+Exec,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, Exec, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis">FuncAnalysis</a>&lt;'a, Exec, State&gt;<div class="where">where
    &lt;Exec as <a class="trait" href="../exec_state/trait.ExecutionState.html" title="trait scarf::exec_state::ExecutionState">ExecutionState</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="../exec_state/trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a>,</div></h3></section><section id="impl-RefUnwindSafe-for-FuncAnalysis%3C'a,+Exec,+State%3E" class="impl"><a href="#impl-RefUnwindSafe-for-FuncAnalysis%3C'a,+Exec,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, Exec, State&gt; !<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis">FuncAnalysis</a>&lt;'a, Exec, State&gt;</h3></section><section id="impl-Send-for-FuncAnalysis%3C'a,+Exec,+State%3E" class="impl"><a href="#impl-Send-for-FuncAnalysis%3C'a,+Exec,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, Exec, State&gt; !<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis">FuncAnalysis</a>&lt;'a, Exec, State&gt;</h3></section><section id="impl-Sync-for-FuncAnalysis%3C'a,+Exec,+State%3E" class="impl"><a href="#impl-Sync-for-FuncAnalysis%3C'a,+Exec,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, Exec, State&gt; !<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis">FuncAnalysis</a>&lt;'a, Exec, State&gt;</h3></section><section id="impl-Unpin-for-FuncAnalysis%3C'a,+Exec,+State%3E" class="impl"><a href="#impl-Unpin-for-FuncAnalysis%3C'a,+Exec,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, Exec, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis">FuncAnalysis</a>&lt;'a, Exec, State&gt;<div class="where">where
    &lt;Exec as <a class="trait" href="../exec_state/trait.ExecutionState.html" title="trait scarf::exec_state::ExecutionState">ExecutionState</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="../exec_state/trait.ExecutionState.html#associatedtype.VirtualAddress" title="type scarf::exec_state::ExecutionState::VirtualAddress">VirtualAddress</a>: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Exec: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    State: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-FuncAnalysis%3C'a,+Exec,+State%3E" class="impl"><a href="#impl-UnwindSafe-for-FuncAnalysis%3C'a,+Exec,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, Exec, State&gt; !<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.FuncAnalysis.html" title="struct scarf::analysis::FuncAnalysis">FuncAnalysis</a>&lt;'a, Exec, State&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#791">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#794">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#773-775">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#783">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#833-835">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#837">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#840">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#817-819">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#821">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#824">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>